##' @include ProtModelFit.R
NULL


##' @title ProtModelFitMFVB class
##'
##' @aliases ProtModelFitMFVB-class, ProtModelFitMFVB
##'
##' @name ProtModelFitMFVB-class
##'
##' @rdname ProtModelFitMFVB
##'
##' @description
##'
##' This class encapsulates a MFVB model fit for proteomics data analysis.
##'
##' Object is created internally when runModel() is called on a StanProt object
##' and stored as a slot in this object
##'
##' @slot fitResults A `list()` of results related to the fit procedure
##' 
##' @slot distrMap A `list()` containing the static mapping to the various
##' distributions functions
##'
##' @slot paramDistr A `list()` containing the per parameter probability 
##' distributions info generated by the MFVB algorithm.
##'
##' @import methods
##' 
##' @exportClass ProtModelFitMFVB
##'

.ProtModelFitMFVB <-
  setClass("ProtModelFitMFVB",
           contains = "ProtModelFit",
           slots = c(
             fitResults = "list",
             distrMap = "list",
             paramDistr = "list"),
           prototype = list(
             ModelSpecPars = ProtModelSpecPars(),
             algoArgs = list(),
             fullStorage = FALSE
           ))


##' @param .ModelSpecPars A `StanModelSpecPars` object containing the model
##' specification parameters.
##' 
##' @param .algoArgs A `list` object containing algorithm tuning parameters
##' 
##' @param .fullStorage A `logical` indicating whether full storage of parameters
##' information is done after run
##' 
##' @param .fitResults A `list()` of results related to the fit procedure
##' 
##' @param .paramDistr A `list()` containing the per parameter probability 
##' distributions generated by the MFVB algorithm.
##' 
##' @return An object of class `ProtModelFitMFVB`
##'
##' @rdname ProtModelFit
##'
##' @export
ProtModelFitMFVB <- function(.ModelSpecPars = ProtModelSpecPars(),
                             .algoArgs = list(),
                             .fullStorage = FALSE,
                             .fitResults = list(),
                             .paramDistr = list()) {
  
  ## Any data preparation needed before instantiating the new object
  .distrMap <- initDistributionsMap()
  
  .ProtModelFitMFVB(ModelSpecPars = .ModelSpecPars,
                    algoArgs = .algoArgs,
                    fullStorage = .fullStorage,
                    fitResults = .fitResults,
                    distrMap = .distrMap,
                    paramDistr = .paramDistr)
             
}

setMethod("show", "ProtModelFitMFVB",
          function(object) {
            cat("Message of class ProtModelFitMFVB:\n")
            cat(" ModelSpecPars:\n")
            show(object@ModelSpecPars)
            cat(" algoArgs:\n")
            show(object@algoArgs)
            cat(" fullStorage:", object@fullStorage, "\n")
            cat(" fitResults:", length(object@fitResults), "\n")
            cat(" distrMap:", length(object@distrMap), "\n")
            cat(" paramDistr:", length(object@paramDistr), "\n")
          })


##' @importFrom stats dnorm qnorm rnorm dgamma qgamma rgamma
##' @importFrom EnvStats dnormTrunc qnormTrunc rnormTrunc
##' @importFrom extraDistr dinvgamma qinvgamma rinvgamma
##' @export
initDistributionsMap <- function(){
  distrMap <- list()
  distrMap[["norm"]] <- list()
  distrMap[["norm"]]$pdf <- stats::dnorm
  distrMap[["norm"]]$qf <- stats::qnorm
  distrMap[["norm"]]$rf <- stats::rnorm
 
  distrMap[["gamma"]]$pdf <- stats::dgamma
  distrMap[["gamma"]]$qf <- stats::qgamma
  distrMap[["gamma"]]$rf <- stats::rgamma
  
  distrMap[["invgamma"]]$pdf <- extraDistr::dinvgamma
  distrMap[["invgamma"]]$qf <- extraDistr::qinvgamma
  distrMap[["invgamma"]]$rf <- extraDistr::rinvgamma
  
  distrMap[["normTrunc"]]$pdf <- EnvStats::dnormTrunc
  distrMap[["normTrunc"]]$qf <- EnvStats::qnormTrunc
  distrMap[["normTrunc"]]$rf <- EnvStats::rnormTrunc
  
  distrMap[["ANu"]]$pdf <- dANu
  distrMap[["ANu"]]$qf <- qANu
  distrMap[["ANu"]]$rf <- rANu
  
  distrMap
}

##' @export
sumProtModelFitMFVB <- function(object, ...){
  stopifnot(inherits(object, "ProtModelFitMFVB"))
  args <- list(...)
  if(is.null(args$probs)){
    probs <-  c(0.025,0.25,0.5,0.75,0.975)
  } else {
    probs <- args$probs
  }
  
  if(is.null(args$detailed)){
    detailed <- FALSE
  } else {
    detailed <- args$detailed
  }
  
  
  # build summary
  nQ <- length(probs)
  
  nDistrToBeOutput <- 0
  for(i in seq_along(object@paramDistr)){
    if(detailed || object@paramDistr[[i]]$main){
      nDistrToBeOutput <- nDistrToBeOutput + 1
    }
  }
  theSummary <- as.data.frame(matrix(nrow = nDistrToBeOutput, ncol = 2+nQ))
  colnames(theSummary) <- c("mean","sd",paste0(probs*100,"%"))
  sumRownames <- rep(" ", nDistrToBeOutput)
  
  i <- 0
  for(dd in seq_along(object@paramDistr)){
    #cat("Distribution ", dd, "\n")
    if(detailed || object@paramDistr[[dd]]$main){
      i <- i+1
      sumRownames[i] <- names(object@paramDistr)[dd]
      theSummary[i,1] <- object@paramDistr[[dd]]$mean
      theSummary[i,2] <- object@paramDistr[[dd]]$sd
      theSummary[i,2+(1:nQ)] <- 
        do.call(what = object@distrMap[[object@paramDistr[[dd]]$type]]$qf, 
                args = c(list(p = probs), 
                         object@paramDistr[[dd]]$args))
    }
  }
  
  rownames(theSummary) <- sumRownames
  
  theSummary
} 


setMethod("summary", "ProtModelFitMFVB", sumProtModelFitMFVB)



# getters and setters

##' @export
paramDistr <- function(object){
  stopifnot(inherits(object, "ProtModelFitMFVB"))
  return(object@paramDistr)
}

##' @export
fitResults <- function(object){
  stopifnot(inherits(object, "ProtModelFitMFVB"))
  return(object@fitResults)
}

# Other useful functions
##' @import ggplot2
##' 
##' @export
showFitResults <- function(object, whichProtein = 1){
  stopifnot(inherits(object, "ProtModelFitMFVB"))
  
  if(whichProtein > length(fitResults(object))){
    stop("whichProtein argument too big, either > nProt or per protein results not available")
  }
  if(is.null(names(fitResults(object)))){
    # global fit results
    res <- fitResults(object)[[whichProtein]]
  } else {
    res <- fitResults(object)
  }
  
  cat("nIterations run : ", res$nIter,
      "; converged : ", res$converged, 
      "; Time elapsed : ", res$elapsed,"\n\n")
  
  df <- data.frame(iter <- res$ELBOIter,
                   ELBO <- res$ELBOValue)
  ggplot(df, aes(x = iter, y = ELBO)) +
    geom_point()
}

##' @export
##' 
##' @author Philippe Hauchamps  
getFinalValues.ProtModelFitMFVB <- function(x, whichValue = "mean"){
  stopifnot(inherits(x, "ProtModelFitMFVB"))
  
  if(whichValue != "mean" && whichValue != "median") 
    stop("'whichValue' argument not recognized, should be [mean] or [median]")
  
  nDistr <- length(x@paramDistr)
  finalValues <- data.frame(name = names(x@paramDistr),
                            value = rep(0., nDistr))
  #startTime <- Sys.time()
  if(whichValue == "mean"){
    finalValues$value <- sapply(x@paramDistr, 
                                FUN = function(distr){
                                  distr$mean
                                })
  } else {
    finalValues$value <- 
      sapply(x@paramDistr, 
             FUN = function(distr, modelfit){
               do.call(modelfit@distrMap[[distr$type]]$qf, 
                       args = c(list(p = c(0.5)),
                                distr$args))
               },
             modelfit = x)
  }
  #endTime <- Sys.time()
  #cat("time needed to retrieve finals : ", endTime - startTime, "\n")
  
  finalValues
  
  # finalValues <- list()
  # distrNames <- names(x@paramDistr)
  # for(i in seq_along(x@paramDistr)){
  #   if(whichValue == "mean"){
  #     value <- x@paramDistr[[i]]$mean
  #   } else {
  #     value <- do.call(x@paramDistr[[i]]$qf, 
  #                      args = c(list(p = c(0.5)), 
  #                               x@paramDistr[[i]]$args))
  #   }
  #   finalValues[[distrNames[i]]] = value
  # }
  # finalValues
}

setMethod("getModelFitFinalValues", "ProtModelFitMFVB",
          getFinalValues.ProtModelFitMFVB)

##' @export
##' 
##' @author Philippe Hauchamps 
getParamSample.ProtModelFitMFVB <- function(x, paramName){
  stopifnot(inherits(x, "ProtModelFitMFVB"))
  
  paramDistrNames <- names(x@paramDistr)
  if(paramName %in% paramDistrNames){
    sample <- do.call(x@distrMap[[x@paramDistr[[paramName]]$type]]$rf,
                      args = c(list(n = 10000),
                               x@paramDistr[[paramName]]$args))
    
  } else {
    msg <- paste0(paramName, " not found in object!")
    stop(msg)
  }
  
  sample
  
}


setMethod("getModelFitParamSample", "ProtModelFitMFVB",
          getParamSample.ProtModelFitMFVB)

