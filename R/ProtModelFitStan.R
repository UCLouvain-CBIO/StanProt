##' @include ProtModelFit.R
NULL


##' @title ProtModelFitStan class
##'
##' @aliases ProtModelFitStan-class, ProtModelFitStan
##'
##' @name ProtModelFitStan-class
##'
##' @rdname ProtModelFitStan
##'
##' @description
##'
##' This class encapsulates a stan model fit for proteomics data analysis.
##'
##' Object is created internally when runModel() is called on a StanProt object
##' and stored as a slot in this object
##'
##' @slot modelScript A `character(1)` designating the model script to be used
##' 
##' @slot runMode A `character(1)` specifying the run mode of the stan fit object
##' can be 'sampling', 'MFVB', or 'MAP'
##' 
##' @slot recompileModelEachTime A `logical` stating whether stan model should
##' be recompiled anyway, even when compiled object is present from disk
##' This is done as a work-around to issue observed when using stan together 
##' with BiocParalel (MulticoreParam)
##' 
##' @slot stanResList A `list` of results which are generated by STAN at run time.
##' Multi-element list is created when running the Stan model protein by protein.
##' A list element containing only one or two entries which can be :
##' - `Stanfit` : a Stanfit object if runMode == "sampling" or "MFVB" and 
##' fullStorage is TRUE
##' - `StanMapRes` : the stan generated object when runMode == "MAP" whatever
##' the value of fullStorage (TRUE or FALSE)
##' - `StanSummary` : a summary table with mean, sd, and standard quantiles 
##' by parameter if fullStorage is FALSE (all run modes, except MAP)
##' - `StanDiagnostics` : a list containing diagnostic elements if fullStorage
##' is FALSE (all run modes, except MAP)
##' 
##' @slot protIndexList A `list` of indexes variables, only used internally to 
##' access and converts the different stanfit objects parameter names, when the 
##' Stan model has been run protein by protein.
##'
##' @import methods
##' 
##' @import rstan
##' 
##' @exportClass ProtModelFitStan
##'
.ProtModelFitStan <-
  setClass("ProtModelFitStan",
           contains = "ProtModelFit",
           slots = c(
             modelScript = "character",
             runMode = "character",
             recompileModelEachTime = "logical",
             stanResList = "list",
             protIndexList = "list"),
           prototype = list(
             modelScript = NULL,
             runMode = "sampling",
             recompileModelEachTime = FALSE,
             ModelSpecPars = ProtModelSpecPars(),
             algoArgs = list(),
             fullStorage = FALSE
           ))


##' @param .modelScript A `character(1)` designating the model script to be used
##' 
##' @param .runMode A `character(1)` specifying the run mode of the stan fit object
##' can be 'sampling', 'MFVB', or 'MAP'
##' 
##' @param .ModelSpecPars A `StanModelSpecPars` object containing the model
##' specification parameters.
##' 
##' @param .algoArgs A `list` object containing algorithm tuning parameters
##' 
##' @param .recompileModelEachTime A `logical` stating whether stan model should
##' be recompiled anyway, even when compiled object is present from disk.
##' 
##' @param .fullStorage A `logical` indicating whether full storage will
##' be done after calculation
##' 
##' @return An object of class `ProtModelFitStan`
##'
##' @rdname ProtModelFitStan
##'
##' @export
ProtModelFitStan <- function(.modelScript = NULL,
                             .runMode = "sampling",
                             .ModelSpecPars = StanModelSpecPars(),
                             .algoArgs = list(),
                             .recompileModelEachTime = FALSE,
                             .fullStorage = FALSE) {
  
  ## Any data preparation needed before instantiating the new object
  .ProtModelFitStan(modelScript = .modelScript,
                    runMode = .runMode,
                    ModelSpecPars = .ModelSpecPars,
                    algoArgs = .algoArgs,
                    recompileModelEachTime = .recompileModelEachTime,
                    fullStorage = .fullStorage)
}

# getters and setters
##' @export
modelScript <- function(object){
  stopifnot(inherits(object, "ProtModelFitStan"))
  return(object@modelScript)
}

##' @export
"modelScript<-" <- function(object, value){
  stopifnot(inherits(object, "ProtModelFitStan"))
  stopifnot(is.character(value))
  object@modelScript <- value
  return(object)
}

##' @export
runMode <- function(object){
  stopifnot(inherits(object, "ProtModelFitStan"))
  return(object@runMode)
}



##' @export
"runMode<-" <- function(object, value){
  stopifnot(inherits(object, "ProtModelFitStan"))
  stopifnot(is.character(value))
  if(value != "sampling" && value != "MFVB" && value != "MAP"){
    msg <- paste0("Cannot set runMode to [", value, "] : ")
    msg <- paste0(msg, "Possible run modes are [sampling], [MFVB] and [MAP]")
    stop(msg)
  }
  object@runMode <- value
  return(object)
}

##' @export
recompileModelEachTime <- function(object){
  stopifnot(inherits(object, "ProtModelFitStan"))
  return(object@recompileModelEachTime)
}

##' @export
"recompileModelEachTime<-" <- function(object, value){
  stopifnot(inherits(object, "ProtModelFitStan"))
  stopifnot(is.logical(value))
  object@recompileModelEachTime <- value
  return(object)
}

setMethod("show", "ProtModelFitStan",
          function(object) {
            cat("Message of class ProtModelFitStan:\n")
            cat(" modelScript:", object@modelScript, "\n")
            cat(" runMode:", object@runMode, "\n")
            cat(" ModelSpecPars:\n")
            show(object@ModelSpecPars)
            cat(" algoArgs:\n")
            show(object@algoArgs)
            cat(" fullStorage:", object@fullStorage, "\n")
          })

##' @importFrom stringr str_locate_all str_sub
##' @export
translateParamNames <- function(object, 
                                paramNames,
                                whichProt){
  stopifnot(inherits(object, "ProtModelFitStan"))
  if(is.null(object@protIndexList)){
    stop("protIndexList missing (=unexpected inconsistency)")
  }
  
  k <- whichProt
  
  if(k == 1){
    obsmove <- 0
    mismove <- 0
    amove <- 0
    bmove <- 0
    cmove <- 0
    smove <- 0
    conmove <- 0
  } else {
    obsmove <- sum(object@protIndexList$NObs[1:(k-1)])
    mismove <- sum(object@protIndexList$NMis[1:(k-1)])
    amove <- sum(object@protIndexList$MAlpha[1:(k-1)])
    bmove <- sum(object@protIndexList$MBeta[1:(k-1)])
    cmove <- sum(object@protIndexList$MGamma[1:(k-1)])
    smove <- (k-1) * object@protIndexList$nRdm
    conmove <- 
      sum(object@protIndexList$nContrast[1:(k-1)])
  }
  
  paramRoots <- c("alpha", "beta", "gamma", "sigma2Eps", "sigmaEps", "tauEps", 
                  "sigma2Rdm", "sigmaRdm",  "tauRdm", "yMis", "bObs", "bMis", 
                  "invBObs", "invBMis", "aObs", "aMis", "gammY", "contrast")
  moves <- c(amove, bmove, cmove, k-1, k-1, k-1,
             smove, smove, smove, mismove, obsmove, mismove, 
             obsmove, mismove, obsmove, mismove, k-1, conmove)
  
  newParamNames <- rep("", length(paramNames))
  
  for(i in seq_along(paramNames)){
    p <- paramNames[i]
    rootFound <- FALSE
    for(j in seq_along(paramRoots)){
      if(str_detect(p, paramRoots[j])){
        root <- paramRoots[j]
        move <- moves[j]
        rootFound <- TRUE
        next
      }
    }
    
    if(rootFound){
      breaksPos <- str_locate_all(p, "\\[")[[1]]
      if(nrow(breaksPos) == 0){
        stop("inconsistency : param name detected without [] while it should have it.")
      }
      lastBreakPos <- breaksPos[nrow(breaksPos),1]
      
      paramIndexStr <- str_sub(p, start = lastBreakPos+1, end = -2)
      if(paramIndexStr == ""){
        stop("inconsistency : param name detected which does not end with [xx]n while it should.")
      }
      paramIndex<- as.integer(paramIndexStr)
      newParamNames[i] <- paste0(root, "[", paramIndex + move, "]")
    } else {
      newParamNames[i] <- paste0(p, "[", k, "]")
    }
    
  }
  
  newParamNames
}

##' @export
interpolateSTANSummary <- function(existingSumm, probs){
 nColExisting <- ncol(existingSumm)
 nParams <- nrow(existingSumm)
 nQ <- length(probs)
 
 nExistingProbs <- nColExisting - 5
 existingProbs <- rep(0., nExistingProbs)
 for(k in 1:nExistingProbs){
   theColName <- colnames(existingSumm)[3+k]
   pctCharLoc <- str_locate(theColName, "%")
   if(is.na(pctCharLoc[[1]])){
     stop("Summary col name without [%] = unexpected inconsistency")
   }
   probStr <- str_sub(theColName, 1, pctCharLoc[[1]]-1)
   existingProbs[k] <- as.numeric(probStr)/100
 }
 
 newSumm <- data.frame(matrix(nrow = nParams, ncol = nQ+5))
 rownames(newSumm) <- rownames(existingSumm)
 colnames(newSumm) <- c("mean","se_mean", "sd", paste0(probs*100,"%"), 
                        "n_eff", "Rhat")
 
 newSumm[,1:3] <- existingSumm[,1:3]
 newSumm[,(nQ+4):(nQ+5)] <- existingSumm[,(nColExisting-1):nColExisting]
 for(j in 1:nParams){
   theQuantiles <- 
     approx(x = existingProbs, 
            y = existingSumm[j, 4:(nColExisting-2)],
            xout = probs,
            rule = 1,
            method = "linear")
   newSumm[j, 4:(nQ+3)] <- theQuantiles$y
 }
 newSumm
}

##' @export
sumProtModelFitStan <- function(object, ...){
  args <- list(...)
  if(is.null(args$probs)){
    probs <-  c(0.025,0.25,0.5,0.75,0.975)
  } else {
    probs <- args$probs
  }
  if(object@runMode == "sampling" || object@runMode == "MFVB"){
    if(object@fullStorage){
      summ <- summary(object@stanResList[[1]]$Stanfit, probs = probs)$summary
    } else {
      summ <- interpolateSTANSummary(object@stanResList[[1]]$StanSummary, probs = probs)
    }
    if(length(object@stanResList) > 1){
      rownames(summ) <- translateParamNames(object,
                                            rownames(summ), 
                                            whichProt = 1)
      for(k in 2:length(object@stanResList)){
        if(object@fullStorage){
          newSumm <- summary(object@stanResList[[k]]$Stanfit, probs = probs)$summary
        } else {
          newSumm <- interpolateSTANSummary(object@stanResList[[k]]$StanSummary, probs = probs)
        }
        
        rownames(newSumm) <- translateParamNames(object,
                                                 rownames(newSumm), 
                                                 whichProt = k)
        summ <- rbind(summ, newSumm)
      }
    } 
    
  } else {
    # for MAP runMode, only a results list might be available from stan
    # depends on draws set or not
    if(object@algoArgs$draws > 0){
      nQ <- length(probs)
      nParams <- ncol(object@stanResList[[1]]$StanMAPRes$theta_tilde)
      summ <- as.data.frame(matrix(nrow = nParams, ncol = 2+nQ))
      rownames(summ) <- colnames(object@stanResList[[1]]$StanMAPRes$theta_tilde)
      colnames(summ) <- c("mean","sd",paste0(probs*100,"%"))
      
      for(dd in 1:nParams){
        summ[dd,1] <- mean(object@stanResList[[1]]$StanMAPRes$theta_tilde[,dd])
        summ[dd,2] <- sd(object@stanResList[[1]]$StanMAPRes$theta_tilde[,dd])
        summ[dd,2+(1:nQ)] <- 
          quantile(object@stanResList[[1]]$StanMAPRes$theta_tilde[,dd], 
                   probs = probs)
      }
    } else {
      summ <- data.frame(estimate = object@stanResList[[1]]$StanMAPRes$par)
    }
    if(length(object@stanResList) > 1){
      rownames(summ) <- translateParamNames(object,
                                            rownames(summ), 
                                            whichProt = 1)
      for(k in 2:length(object@stanResList)){
        if(object@algoArgs$draws > 0){
          nParams <- ncol(object@stanResList[[k]]$StanMAPRes$theta_tilde)
          newSumm <- as.data.frame(matrix(nrow = nParams, ncol = 2+nQ))
          rownames(newSumm) <- 
            colnames(object@stanResList[[k]]$StanMAPRes$theta_tilde)
          colnames(newSumm) <- c("mean","sd",paste0(probs*100,"%"))
          
          for(dd in 1:nParams){
            newSumm[dd,1] <- 
              mean(object@stanResList[[k]]$StanMAPRes$theta_tilde[,dd])
            newSumm[dd,2] <- 
              sd(object@stanResList[[k]]$StanMAPRes$theta_tilde[,dd])
            newSumm[dd,2+(1:nQ)] <- 
              quantile(object@stanResList[[k]]$StanMAPRes$theta_tilde[,dd], 
                       probs = probs)
          }
        } else {
          newSumm <- 
            data.frame(estimate = object@stanResList[[k]]$StanMAPRes$par)
        }
        rownames(newSumm) <- translateParamNames(object,
                                                 rownames(newSumm), 
                                                 whichProt = k)
        summ <- rbind(summ, newSumm)
      }
    } 
  }
  summ
}
 
setMethod("summary", "ProtModelFitStan", sumProtModelFitStan)




##' @export
##' 
##' @author Philippe Hauchamps  
getFinalValues.ProtModelFitStan <- function(x, whichValue = "mean"){
  stopifnot(inherits(x, "ProtModelFitStan"))
  
  if(whichValue != "mean" && whichValue != "median") 
    stop("'whichValue' argument not recognized, should be [mean] or [median]")
  
  summ <- sumProtModelFitStan(x, probs = c(0.5))
  
  if(x@runMode == "MAP" && x@algoArgs$draws == 0){
    targetColName <- "estimate"
  } else {
    targetColName <- ifelse(whichValue == "mean", "mean", "50%")
  }
  
  finalValues <- data.frame(paramName = rownames(summ),
                            paramValue = summ[, targetColName])
  finalValues
}

setMethod("getModelFitFinalValues", "ProtModelFitStan",
          getFinalValues.ProtModelFitStan)

##' @importFrom stringr str_locate_all str_sub
##' 
##' @importFrom dplyr lag
##' 
##' @export
findParam <- function(x, paramName){
  stopifnot(inherits(x, "ProtModelFitStan"))
  myList <- x@stanResList
  
  nProt <- length(myList)
  if(nProt > 1){
    p <- paramName
    breaksPos <- str_locate_all(p, "\\[")[[1]]
    if(nrow(breaksPos) == 0){
      stop("multiple model fit found and no [] in param name => param name not found")
    }
    lastBreakPos <- breaksPos[nrow(breaksPos),1]
    
    paramIndexStr <- str_sub(p, start = lastBreakPos+1, end = -2)
    if(paramIndexStr == ""){
      stop("multiple model fit found and no [] in param name => param name not found")
    }
    paramIndex<- as.integer(paramIndexStr)
    root <- str_sub(p, start = 1, end = lastBreakPos-1)
    
    obs <- x@protIndexList$NObs
    mis <- x@protIndexList$NMis
    a <- x@protIndexList$MAlpha
    b <- x@protIndexList$MBeta
    c <- x@protIndexList$MGamma
    s <- rep(x@protIndexList$nRdm, nProt)
    con <- x@protIndexList$nContrast
    def <- rep(1, nProt)
    
    
    paramRoots <- c("alpha", "beta", "gamma", "sigma2Eps", "sigmaEps", "tauEps", 
                    "sigma2Rdm", "sigmaRdm",  "tauRdm", "yMis", "bObs", "bMis", 
                    "invBObs", "invBMis", "aObs", "aMis", "gammY", "contrast")
    indexArrays <- list(a, b, c, def, def, def,
               s, s, s, mis, obs, mis, 
               obs, mis, obs, mis, def, con)
    rootFound <- FALSE
    for(j in seq_along(paramRoots)){
      if(root == paramRoots[j]){
        rootFound = TRUE
        cs <- cumsum(indexArrays[[j]])
        if(paramIndex < 0 || paramIndex > cs[length(cs)]){
          stop("parameter index not found")
        }
        k <- which(cs>=paramIndex)[1]
        newIndex <- paramIndex - (lag(cs, default = 0)[k])
        newParamName <- paste0(root, "[", newIndex, "]")
        break
      }
    }
    if(!rootFound){
      stop("parameter name root not found")
    }
      
  
  } else {
    # no need to translate param name
    k <- 1
    newParamName <- paramName
  }
  
  
  res <- list(whichModel = k, 
              paramName = newParamName)
}

##' @export
getSamplesFromSTANSummary <- function(n, StanSummary, paramName){
  nColSummary <- ncol(StanSummary)
  if(paramName %in% rownames(StanSummary)){
    paramRow <- which(rownames(StanSummary) == paramName)
  } else {
    msg <- paste0("parameter name", paramName, "not found in Stan summary")
    stop(msg)
  }
  
  nProbs <- nColSummary - 5
  probs <- rep(0., nProbs)
  for(k in 1:nProbs){
    theColName <- colnames(StanSummary)[3+k]
    pctCharLoc <- str_locate(theColName, "%")
    if(is.na(pctCharLoc[[1]])){
      stop("Summary col name without [%] = unexpected inconsistency")
    }
    probStr <- str_sub(theColName, 1, pctCharLoc[[1]]-1)
    probs[k] <- as.numeric(probStr)/100
  }
    
  unifSamples <- runif(n)
  theSamples <- 
    approx(x = probs,
           y = StanSummary[paramRow,4:(nColSummary-2)],
           xout = unifSamples,
           method = "linear",
           rule = 2)$y
  theSamples
    
}

##' @export
getParamSample.ProtModelFitStan <- function(x, paramName){
  stopifnot(inherits(x, "ProtModelFitStan"))
  
  res <- findParam(x, paramName)
  
  if(x@runMode == "sampling" || x@runMode == "MFVB"){
    if(x@fullStorage){
      tryCatch(
        error = function(cnd){
          msg <- "stan fit samples could not be extracted for parameter "
          msg <- paste0(msg, paramName, ".")
          stop(msg)
        },
        STAN_array <<- rstan::extract(x@stanResList[[res$whichModel]]$Stanfit,
                                      res$paramName)
      )
      samples <- STAN_array[[1]]
    } else {
      samples <- 
        getSamplesFromSTANSummary(n = 10000, 
                                  StanSummary = x@stanResList[[res$whichModel]]$StanSummary,
                                  paramName = res$paramName)
    }
    
  } else {
    if(algoArgs(x)$draws > 0){
      theSamples <- x@stanResList[[res$whichModel]]$StanMAPRes$theta_tilde
      if(res$paramName %in% colnames(theSamples)){
        samples <- theSamples[, res$paramName]
      } else {
        msg <- paste0(paramName, " not found in object!")
        stop(msg)
      }
    } else {
      summ <- 
        data.frame(estimate = x@stanResList[[res$whichModel]]$StanMAPRes$par)
      if(res$paramName %in% rownames(summ)){
        value <- summ[res$paramName, "estimate"]
        samples <- rep(value, 10000)
      } else {
        msg <- paste0(paramName, " not found in object!")
        stop(msg)
      }
      
    }
     
  }
  
  samples
  
}


setMethod("getModelFitParamSample", "ProtModelFitStan",
          getParamSample.ProtModelFitStan)

