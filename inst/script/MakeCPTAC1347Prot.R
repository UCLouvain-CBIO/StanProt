### script used to build CPTAC1347prot Summarized Experiment

### This dataset is derived from the CPTAC Technology Assessment Study 6 
### dataset, which has been produced to assess the repeatability and 
### reproducibility of the MS technology for proteomics data analysis. 
### (https://cptac-data-portal.georgetown.edu/cptac/study/list/10423?scope=Phase+I#10423)

### This dataset has  been used as benchmark dataset in the following 
### MSqRob articles : [Goeminne, Gevaert, and Clement 2016] and 
### [Goeminne, Sticker, et al. 2020].

### The initial data are the peptide and proteinGroups txt file generated by
### MaxQuant, downloaded from the following github repository:
### https://github.com/statOmics/MSqRobHurdlePaper
### 
### The pre-processing and MaxQuant settings are described in 
### [Goeminne, Gevaert, and Clement 2016]
###
### References:
### 
### Goeminne, Ludger J. E., Kris Gevaert, and Lieven Clement. 2016. 
### “Peptide-Level Robust Ridge Regression Improves Estimation, Sensitivity, 
### and Specificity in Data-Dependent Quantitative Label-Free Shotgun 
### Proteomics.” Molecular & Cellular Proteomics: MCP 15 (2): 657–68.
###
### Goeminne, Ludger J. E., Adriaan Sticker, Lennart Martens, Kris Gevaert, 
### and Lieven Clement. 2020. “MSqRob Takes the Missing Hurdle: Uniting 
### Intensity- and Count-Based Proteomics.” 
### Analytical Chemistry 92 (9): 6278–87. 

require(QFeatures)
require(magrittr)
require(dplyr)
require(tidyr)

rm(list=ls())

##### DATA PRE_PROCESSING #####

# 0. Specify raw data path
# Note: MaxQuant files were taken from the following repo:
#
# and generated according to description made in the following article:
#

datasetPath <- "./inst/extdata"
file.peptides.txt <- paste0(datasetPath, "/peptides.txt")
file.proteinGroups <- paste0(datasetPath, "/proteinGroups.txt")

# 1. Build QFeatures containing peptides data

(intensityCols <- grep("Intensity\\.", names(read.delim(file.peptides.txt))))

cptac.peptides <- readSummarizedExperiment(file.peptides.txt, 
                                           ecol = intensityCols, 
                                           sep = "\t", 
                                           fnames = "Sequence")

colnames(cptac.peptides) <- sub("Intensity\\.", 
                                "", 
                                colnames(cptac.peptides))

# build temporary feature data.frame 
# note the potential contaminant column excludes the ups protein
peptides.fd <- rowData(cptac.peptides) %>% as.data.frame() %>% 
  transmute(
    sequence = Sequence,
    reverse = grepl("\\+", Reverse),
    #contaminant = grepl("\\+", Potential.contaminant),
    protein = Proteins %>% as.character,
    contaminant = grepl("CON__", protein) & !grepl("ups", protein),
    gene.name = Gene.names,
    protein.name = Protein.names,
    Leading.razor.protein
  )

# joins with protein file (key = "protein" column),
# in order to use 'Only.identified.by.site' column,
# which is a characteristic of proteins, not peptides
proteins.table <- read.table(file.proteinGroups,
                             sep = "\t",
                             header = TRUE,
                             quote = "",
                             comment.char = "",
                             stringsAsFactors = FALSE) 


peptides.fd <- proteins.table %>%
  transmute(protein = Protein.IDs,
            only.site = grepl("\\+", Only.identified.by.site)) %>% 
  right_join(peptides.fd) %>% arrange(sequence)

# !!!!!! 
# the following causes error in QFeatures::aggregateFeatures()
#peptides.fd$protein <- peptides.fd$protein %>% as.factor

# We assume that the proteins identifiers that were not retained in MaxQuant's
# proteinGroups.txt file were not "only identified by site"
peptides.fd$only.site[is.na(peptides.fd$only.site)] <- FALSE

rowData(cptac.peptides) <- peptides.fd

cptac <- QFeatures(list(peptides = cptac.peptides))
glimpse(assay(cptac[[1]]))

rm(cptac.peptides, peptides.fd, proteins.table)

# 2. Encode experimental design
samples <- rep(1:9, 3)
cptac$condition <- as.factor(rep(c("6A","6B","6C"), each = 9))
cptac$lab <- as.factor(rep(rep(c( "LTQ-Orbitrap_86",
                                  "LTQ-OrbitrapO_65",
                                  "LTQ-OrbitrapW_56"), each = 3), 3))

cptac$run <- paste(cptac$condition, samples, sep = "_" )

levels(colData(cptac)$lab) <- c("1","2","3")

colData(cptac)


# 3a. Filtering out contaminants and reverse hits, 
# filtering also peptides for which the protein is only identified by sequences 
# having post translational modifications (PTM) ('Only identified by site')

# here : 9863 features
(cptac <- cptac %>% filterFeatures( ~ reverse == FALSE ))
# here : 9831 features
(cptac <- cptac %>% filterFeatures( ~ contaminant == FALSE ))
# here : 9797 features
(cptac <- cptac %>% filterFeatures( ~ only.site == FALSE))
# here : 9783 features


# 3b. select relevant row data
rowvars <- c("protein","sequence","gene.name","protein.name","Leading.razor.protein")
cptac <- selectRowData(cptac, rowvars)
rowDataNames(cptac)

# 4. Since we also want to work with count data, we do NOT remove peptides 
# that are only identified once in the dataset. 
# (We will do this separately for MSqRob). 
# We do however want to remove all peptides that are NOT identified at all 
# in the given conditions.
sel <- (rowSums(assay(cptac)) > 0)
(cptac <- cptac[sel,,])
# here : 9617 features

# 5. Remove proteins that are only identified by one peptide. 
# Note that there could be interesting proteins in this group. 
# On the other hand, inference done on only one peptide is likely not very reliable. 
# Therefore, we make the choice to remove these proteins from the dataset.
sel <- rowData(cptac[["peptides"]]) %>% 
  as.data.frame() %>%
  group_by(protein) %>% 
  mutate(flag = n() > 1) %>% 
  pull(flag)
(cptac <- cptac[sel,,])
# here : 9377 features

# 6. data transformations

# replaces 0 by NA's, inspect missingness structure
cptac <- zeroIsNA(cptac, i=seq_along(cptac))
nNA(cptac, i=seq_along(cptac))

# log transform data
(cptac <- addAssay(cptac,
                   logTransform(cptac[[1]]),
                   name = "peptides_log"))

# quantile normalize data
require(preprocessCore)
(cptac <- addAssay(cptac,
                   normalize(cptac[["peptides_log"]], method = "quantiles"),
                   name = "peptides_norm"))

# 7. data inspection

# create joined 'long format' data frame joining assay and rowData 
# from quantile normalized peptide intensities summarized experiment, 
# and colData of the QFeatures
peptides.assay <- cptac[["peptides_norm"]] %>% assay %>% as.data.frame 
peptides.assay <- peptides.assay %>% cbind(sequence = row.names(peptides.assay))
peptides.rowdata <- cptac[["peptides_norm"]] %>% rowData %>% as.data.frame
peptides.coldata <- cptac %>% colData %>% as.data.frame

(pa <- pivot_longer( peptides.assay, cols = starts_with("6"), 
                     names_to = "run", values_drop_na = TRUE))

(peptides.join <- pa %>% inner_join(peptides.rowdata)) # uses 'sequence' as a join key
(peptides.join <- peptides.join %>% inner_join(peptides.coldata))

# 7.1
# We first want to know how many human UPS1 proteins are present in the dataset.
peptides.join %>% select(protein) %>% distinct %>% 
  count(ups = grepl('ups', protein))
# # A tibble: 2 x 2
#   ups       n
#   <lgl> <int>
# 1 FALSE  1343
# 2 TRUE     38

# => There are 1343 yeast and 38 UPS1 proteins present in the dataset.

# 7.2

# Here we check how many proteins have only peptides detected in 1 spike-in condition.
# condition1 <- peptides.join %>% select(protein, condition) %>% 
#   distinct %>% group_by(protein) %>% count %>% ungroup %>% filter(n == 1)
# condition1 %>% count(ups = grepl('ups', protein))

condition1 <- peptides.join %>% select(protein, condition) %>% 
  distinct %>% group_by(protein) %>% count %>% ungroup %>% filter(n == 1)
condition1

# A tibble: 0 x 2
# ... with 2 variables: ups <lgl>, nn <int>

# => There are no proteins that are only detected in one spike-in condition.

# 7.3

# Here we check how many proteins have only peptides detected in 1 lab
lab1 <- peptides.join %>% select(protein, lab) %>% 
  distinct %>% group_by(protein) %>% count %>% ungroup %>% filter(n == 1)
lab1 %>% count(ups = grepl('ups', protein))

# A tibble: 1 x 2
# ups       n
# <lgl> <int>
#   1 FALSE    48
rm(condition1, lab1, pa, peptides.join, peptides.assay, peptides.coldata,
   peptides.rowdata)

# 8. Additional preprocessing for peptide based model (e.g. MSqRob)
# For peptide based linear model like MSqRob, we require at least 2 identifications 
# of a peptide sequence, as with 1 identification, the model will be perfectly 
# confounded. We thus further filter the data accordingly.

sel <- (rowSums(!is.na(assay(cptac[["peptides_norm"]]))) >= 2)

(cptac <- cptac[sel,,])
# here : 9192 features

# Again remove proteins that are only identified by one peptide
sel <- rowData(cptac[["peptides_norm"]]) %>% 
  as.data.frame() %>%
  group_by(protein) %>% 
  mutate(flag = n() > 1) %>% 
  pull(flag)
(cptac <- cptac[sel,,])
# here : 9158 features

dim(cptac[["peptides_norm"]])
# 9158   27
length(unique(rowData(cptac[["peptides_norm"]])$protein))
# 1347
toSave <- cptac[["peptides_norm"]]
colData(toSave) <- colData(cptac)

save(toSave, file = "./data/CPTAC1347protCopy.rda")

# as1 <- assay(toSave)
# as2 <- assay(CPTAC1347prot)
# as1
# as2
# all.equal(as1, as2)
# 
# cd1 <- colData(toSave)
# cd2 <- colData(CPTAC1347prot)
# 
# cd1
# cd2
# all.equal(cd1, cd2)
# 
# rd1 <- rowData(toSave)
# rd2 <-rowData(CPTAC1347prot)
# rd1
# rd2
# all.equal(rd1, rd2)
